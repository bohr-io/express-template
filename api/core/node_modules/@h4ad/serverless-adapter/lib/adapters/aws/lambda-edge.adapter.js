"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LambdaEdgeAdapter = exports.__ΩLambdaEdgeAdapterOptions = exports.DEFAULT_ORIGIN_MAX_RESPONSE_SIZE_IN_BYTES = exports.DEFAULT_VIEWER_MAX_RESPONSE_SIZE_IN_BYTES = exports.DEFAULT_LAMBDA_EDGE_DISALLOWED_HEADERS = exports.__ΩOldLambdaEdgeBody = exports.__ΩNewLambdaEdgeBody = exports.__ΩDefaultForwardPath = exports.__ΩDefaultQueryString = void 0;
const { __ΩAdapterRequest } = require('../../contracts');
const { __ΩGetResponseAdapterProps } = require('../../contracts');
const { __ΩOnErrorProps } = require('../../contracts');
const { __ΩSingleValueHeaders } = require('../../@types');
const { __ΩBothValueHeaders } = require('../../@types');
const { __ΩConcrete } = require('../../@types');
function __assignType(fn, args) {
    fn.__type = args;
    return fn;
}
const core_1 = require("../../core");
const __ΩDefaultQueryString = ["Records", "cf", "request", "querystring", '".!f\'f."f.#f.$f'];
exports.__ΩDefaultQueryString = __ΩDefaultQueryString;
const __ΩDefaultForwardPath = ["Records", "cf", "request", "uri", '".!f\'f."f.#f.$f'];
exports.__ΩDefaultForwardPath = __ΩDefaultForwardPath;
const __ΩNewLambdaEdgeBody = ["Records", "cf", "request", "body", '".!f\'f."f.#f.$f'];
exports.__ΩNewLambdaEdgeBody = __ΩNewLambdaEdgeBody;
const __ΩOldLambdaEdgeBody = [() => __ΩConcrete, "Records", "cf", "request", "body", "data", '"."f\'f.#f.$fo!".%f.&f'];
exports.__ΩOldLambdaEdgeBody = __ΩOldLambdaEdgeBody;
/**
 * The list was created based on {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/edge-functions-restrictions.html | these docs} in the "Disallowed Headers" section.
 *
 * @breadcrumb Adapters / AWS / LambdaEdgeAdapter / Constants
 * @public
 */
exports.DEFAULT_LAMBDA_EDGE_DISALLOWED_HEADERS = [
    'Connection',
    'Expect',
    'Keep-Alive',
    'Proxy-Authenticate',
    'Proxy-Authorization',
    'Proxy-Connection',
    'Trailer',
    'Upgrade',
    'X-Accel-Buffering',
    'X-Accel-Charset',
    'X-Accel-Limit-Rate',
    'X-Accel-Redirect',
    /(X-Amz-Cf-)(.*)/gim,
    'X-Cache',
    /(X-Edge-)(.*)/gim,
    'X-Forwarded-Proto',
    'X-Real-IP',
];
/**
 * The default max response size in bytes of viewer request and viewer response.
 *
 * @defaultValue 1024 * 40 = 40960 = 40KB
 *
 * {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html | Reference}
 *
 * @breadcrumb Adapters / AWS / LambdaEdgeAdapter / Constants
 * @public
 */
exports.DEFAULT_VIEWER_MAX_RESPONSE_SIZE_IN_BYTES = 1024 * 40;
/**
 * The default max response size in bytes of origin request and origin response.
 *
 * @defaultValue 1024 * 1024 = 1048576 = 1MB
 *
 * {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html | Reference}
 *
 * @breadcrumb Adapters / AWS / LambdaEdgeAdapter / Constants
 * @public
 */
exports.DEFAULT_ORIGIN_MAX_RESPONSE_SIZE_IN_BYTES = 1024 * 1024;
const __ΩLambdaEdgeAdapterOptions = ['viewerMaxResponseSizeInBytes', 'originMaxResponseSizeInBytes', 'response', '', 'onResponseSizeExceedLimit', "Records", 'event', 'getPathFromEvent', 'disallowedHeaders', 'header', 'shouldStripHeader', 'shouldUseHeadersFromFramework', 'P\'4!8\'4"8P"2#"/$4%8P".&f\'f2\'&/$4(8P&AJF4)8P&2*)/$4+8)4,8M'];
exports.__ΩLambdaEdgeAdapterOptions = __ΩLambdaEdgeAdapterOptions;
/**
 * The adapter to handle requests from AWS Lambda\@Edge.
 *
 * This adapter is not fully compatible with Lambda\@edge supported by \@vendia/serverless-express, the request body was modified to return {@link NewLambdaEdgeBody} instead {@link OldLambdaEdgeBody}.
 * Also, the response has been modified to return entire body sent by the framework, in this form you MUST return the body from the framework in the format of {@link aws-lambda#CloudFrontRequestResult}.
 * And when we get an error during the forwarding to the framework, we call `resolver.fail` instead of trying to return status 500 like the old implementation was.
 *
 * {@link https://docs.aws.amazon.com/lambda/latest/dg/lambda-edge.html | Lambda edge docs}
 * {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html | Event Reference}
 *
 * @example
 * ```typescript
 * const getPathFromEvent = () => '/lambda/edge'; // will forward all requests to the same endpoint
 * const adapter = new LambdaEdgeAdapter({ getPathFromEvent });
 * ```
 *
 * @breadcrumb Adapters / AWS / LambdaEdgeAdapter
 * @public
 */
class LambdaEdgeAdapter {
    //#region Constructor
    /**
     * Default constructor
     *
     * @param options - The options to customize the {@link LambdaEdgeAdapter}
     */
    constructor(options) {
        var _a;
        this.options = options;
        const disallowedHeaders = (0, core_1.getDefaultIfUndefined)((_a = this.options) === null || _a === void 0 ? void 0 : _a.disallowedHeaders, exports.DEFAULT_LAMBDA_EDGE_DISALLOWED_HEADERS);
        this.cachedDisallowedHeaders = disallowedHeaders.map(__assignType(disallowedHeader => {
            if (disallowedHeader instanceof RegExp)
                return disallowedHeader;
            return new RegExp(`(${disallowedHeader})`, 'gim');
        }, ['disallowedHeader', '', 'P"2!"/"']));
    }
    //#endregion
    //#region Public Methods
    /**
     * {@inheritDoc}
     */
    getAdapterName() {
        return LambdaEdgeAdapter.name;
    }
    /**
     * {@inheritDoc}
     */
    canHandle(event) {
        var _a, _b, _c;
        const lambdaEdgeEvent = event;
        if (!Array.isArray(lambdaEdgeEvent === null || lambdaEdgeEvent === void 0 ? void 0 : lambdaEdgeEvent.Records))
            return false;
        const eventType = (_c = (_b = (_a = lambdaEdgeEvent.Records[0]) === null || _a === void 0 ? void 0 : _a.cf) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.eventType;
        const validEventTypes = [
            'origin-response',
            'origin-request',
            'viewer-response',
            'viewer-request',
        ];
        return validEventTypes.includes(eventType);
    }
    /**
     * {@inheritDoc}
     */
    getRequest(event) {
        var _a;
        const request = event.Records[0];
        const cloudFrontRequest = request.cf.request;
        const method = cloudFrontRequest.method;
        const pathFromOptions = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.getPathFromEvent)
            ? this.options.getPathFromEvent(request)
            : undefined;
        const defaultPath = (0, core_1.getPathWithQueryStringParams)(cloudFrontRequest.uri, cloudFrontRequest.querystring);
        const path = (0, core_1.getDefaultIfUndefined)(pathFromOptions, defaultPath);
        const remoteAddress = cloudFrontRequest.clientIp;
        const headers = this.getFlattenedHeadersFromCloudfrontRequest(cloudFrontRequest);
        let body;
        if (cloudFrontRequest.body) {
            const [buffer, contentLength] = (0, core_1.getEventBodyAsBuffer)(JSON.stringify(cloudFrontRequest.body), false);
            body = buffer;
            headers['content-length'] = contentLength.toString();
        }
        const { host } = headers;
        return {
            method,
            path,
            headers,
            body,
            remoteAddress,
            host,
            hostname: host,
        };
    }
    /**
     * {@inheritDoc}
     */
    getResponse(props) {
        var _a, _b, _c;
        const response = this.getResponseToLambdaEdge(props);
        const responseToServiceBytes = new TextEncoder().encode(JSON.stringify(response)).length;
        const isOriginRequestOrResponse = this.isEventTypeOrigin(props.event.Records[0].cf.config);
        const maxSizeInBytes = isOriginRequestOrResponse
            ? (0, core_1.getDefaultIfUndefined)((_a = this.options) === null || _a === void 0 ? void 0 : _a.originMaxResponseSizeInBytes, exports.DEFAULT_ORIGIN_MAX_RESPONSE_SIZE_IN_BYTES)
            : (0, core_1.getDefaultIfUndefined)((_b = this.options) === null || _b === void 0 ? void 0 : _b.viewerMaxResponseSizeInBytes, exports.DEFAULT_VIEWER_MAX_RESPONSE_SIZE_IN_BYTES);
        if (responseToServiceBytes <= maxSizeInBytes)
            return response;
        if ((_c = this.options) === null || _c === void 0 ? void 0 : _c.onResponseSizeExceedLimit)
            this.options.onResponseSizeExceedLimit(response);
        else {
            props.log.error(`SERVERLESS_ADAPTER:LAMBDA_EDGE_ADAPTER: Max response size exceeded: ${responseToServiceBytes} of the max of ${maxSizeInBytes}.`);
        }
        return response;
    }
    /**
     * {@inheritDoc}
     */
    onErrorWhileForwarding({ error, delegatedResolver, }) {
        delegatedResolver.fail(error);
    }
    //#endregion
    //#region Protected Methods
    /**
     * Returns the headers with the flattened (non-list) values of the cloudfront request headers
     *
     * @param cloudFrontRequest - The cloudfront request
     */
    getFlattenedHeadersFromCloudfrontRequest(cloudFrontRequest) {
        const headers = {};
        const headerValuePairs = Object.entries(cloudFrontRequest.headers);
        for (const [headerKey, headerValue] of headerValuePairs)
            headers[headerKey] = headerValue.map(__assignType(header => header.value, ['header', '', 'P"2!"/"'])).join(',');
        return headers;
    }
    /**
     * Returns the framework response in the format required by the Lambda\@edge.
     *
     * @param body - The body of the response
     * @param frameworkHeaders - The headers from the framework
     */
    getResponseToLambdaEdge({ body, headers: frameworkHeaders, }) {
        var _a;
        const shouldUseHeadersFromFramework = (0, core_1.getDefaultIfUndefined)((_a = this.options) === null || _a === void 0 ? void 0 : _a.shouldUseHeadersFromFramework, false);
        const parsedBody = JSON.parse(body);
        if (parsedBody.headers) {
            parsedBody.headers = Object.keys(parsedBody.headers).reduce(__assignType((acc, header) => {
                if (this.shouldStripHeader(header))
                    return acc;
                acc[header] = parsedBody.headers[header];
                return acc;
            }, ['acc', 'header', '', 'P"2!"2""/#']), {});
        }
        if (!shouldUseHeadersFromFramework)
            return parsedBody;
        parsedBody.headers = this.getHeadersForCloudfrontResponse(frameworkHeaders);
        return parsedBody;
    }
    /**
     * Returns headers in Cloudfront Response format.
     *
     * @param originalHeaders - The original version of the request sent by the framework
     */
    getHeadersForCloudfrontResponse(originalHeaders) {
        const originalHeadersEntries = Object.entries(originalHeaders);
        const headers = {};
        for (const [headerKey, headerValue] of originalHeadersEntries) {
            if (this.shouldStripHeader(headerKey))
                continue;
            if (!headers[headerKey])
                headers[headerKey] = [];
            if (!Array.isArray(headerValue)) {
                headers[headerKey].push({
                    key: headerKey,
                    value: headerValue || '',
                });
                continue;
            }
            const headersArray = headerValue.map(__assignType(value => ({
                key: headerKey,
                value: value,
            }), ['value', '', 'P"2!"/"']));
            headers[headerKey].push(...headersArray);
        }
        return headers;
    }
    /**
     * Returns the information if we should remove the response header
     *
     * @param headerKey - The header that will be tested
     */
    shouldStripHeader(headerKey) {
        var _a;
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.shouldStripHeader)
            return this.options.shouldStripHeader(headerKey);
        const headerKeyLowerCase = headerKey.toLowerCase();
        for (const stripHeaderIf of this.cachedDisallowedHeaders) {
            if (!stripHeaderIf.test(headerKeyLowerCase))
                continue;
            return true;
        }
        return false;
    }
    /**
     * Determines whether the event is from origin or is from viewer.
     *
     * @param content - The event sent by AWS or the response sent by the framework
     */
    isEventTypeOrigin(content) {
        return content.eventType.includes('origin');
    }
}
exports.LambdaEdgeAdapter = LambdaEdgeAdapter;
LambdaEdgeAdapter.__type = [() => __ΩLambdaEdgeAdapterOptions, 'options', 'constructor', 'cachedDisallowedHeaders', 'getAdapterName', 'event', 'canHandle', () => __ΩAdapterRequest, 'getRequest', () => __ΩGetResponseAdapterProps, 'props', 'getResponse', () => __ΩOnErrorProps, 'param0', 'onErrorWhileForwarding', 'cloudFrontRequest', () => __ΩSingleValueHeaders, 'getFlattenedHeadersFromCloudfrontRequest', () => __ΩGetResponseAdapterProps, 'getResponseToLambdaEdge', () => __ΩBothValueHeaders, 'originalHeaders', 'getHeadersForCloudfrontResponse', 'headerKey', 'shouldStripHeader', "config", 'content', 'isEventTypeOrigin', 'Pn!2"8<9"0#AF3$9<P&0%P#2&!0\'P"2&n(0)P"o*"2+"0,P""o-#2.$0/P"20n102<P"o3"2."04<Pn526"07<P&28)09<P".:f2;)0<<5"""6$'];
//# sourceMappingURL=lambda-edge.adapter.js.map