"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiGatewayV1Adapter = exports.__ΩApiGatewayV1Options = void 0;
const { __ΩAdapterRequest } = require('../../contracts');
const { __ΩGetResponseAdapterProps } = require('../../contracts');
const { __ΩOnErrorProps } = require('../../contracts');
function __assignType(fn, args) {
    fn.__type = args;
    return fn;
}
const core_1 = require("../../core");
const __ΩApiGatewayV1Options = ['stripBasePath', 'P&4!8M'];
exports.__ΩApiGatewayV1Options = __ΩApiGatewayV1Options;
/**
 * The adapter to handle requests from AWS Api Gateway V1
 *
 * As per {@link https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-known-issues.html | know issues}, we throw an exception when you send the `transfer-encoding=chunked`, currently, API Gateway doesn't support chunked transfer.
 *
 * @remarks This adapter is not fully compatible with \@vendia/serverless-express, on \@vendia they filter `transfer-encoding=chunked` but we throw an exception.
 *
 * @example
 * ```typescript
 * const stripBasePath = '/any/custom/base/path'; // default ''
 * const adapter = new ApiGatewayV1Adapter({ stripBasePath });
 * ```
 *
 * {@link https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html | Event Reference}
 *
 * @breadcrumb Adapters / AWS / ApiGatewayV1Adapter
 * @public
 */
class ApiGatewayV1Adapter {
    //#region Constructor
    /**
     * Default constructor
     *
     * @param options - The options to customize the {@link ApiGatewayV1Adapter}
     */
    constructor(options) {
        this.options = options;
    }
    //#endregion
    //#region Public Methods
    /**
     * {@inheritDoc}
     */
    getAdapterName() {
        return ApiGatewayV1Adapter.name;
    }
    /**
     * {@inheritDoc}
     */
    canHandle(event) {
        const partialEventV1 = event;
        return !!((partialEventV1 === null || partialEventV1 === void 0 ? void 0 : partialEventV1.requestContext) &&
            partialEventV1.version !== '2.0' &&
            partialEventV1.headers &&
            partialEventV1.multiValueHeaders &&
            ((partialEventV1.queryStringParameters === null &&
                partialEventV1.multiValueQueryStringParameters === null) ||
                (partialEventV1.queryStringParameters &&
                    partialEventV1.multiValueQueryStringParameters)));
    }
    /**
     * {@inheritDoc}
     */
    getRequest(event) {
        const method = event.httpMethod;
        const headers = (0, core_1.getFlattenedHeadersMap)(event.headers, ',', true);
        const path = this.getPathFromEvent(event);
        let body;
        if (event.body) {
            const [bufferBody, contentLength] = (0, core_1.getEventBodyAsBuffer)(event.body, event.isBase64Encoded);
            body = bufferBody;
            headers['content-length'] = String(contentLength);
        }
        const remoteAddress = event.requestContext.identity.sourceIp;
        return {
            method,
            headers,
            body,
            remoteAddress,
            path,
        };
    }
    /**
     * {@inheritDoc}
     */
    getResponse({ headers: responseHeaders, body, isBase64Encoded, statusCode, response, }) {
        const multiValueHeaders = (0, core_1.getMultiValueHeadersMap)(responseHeaders);
        const transferEncodingHeader = multiValueHeaders['transfer-encoding'];
        const hasTransferEncodingChunked = transferEncodingHeader &&
            transferEncodingHeader.some(__assignType(value => value.includes('chunked'), ['value', '', 'P"2!"/"']));
        if (hasTransferEncodingChunked) {
            throw new Error('chunked encoding in headers is not supported by API Gateway V1');
        }
        if (response === null || response === void 0 ? void 0 : response.chunkedEncoding) {
            throw new Error('chunked encoding in response is not supported by API Gateway V1');
        }
        return {
            statusCode,
            body,
            multiValueHeaders,
            isBase64Encoded,
        };
    }
    /**
     * {@inheritDoc}
     */
    onErrorWhileForwarding({ error, delegatedResolver, respondWithErrors, event, log, }) {
        const body = respondWithErrors ? error.stack : '';
        const errorResponse = this.getResponse({
            event,
            statusCode: 500,
            body: body || '',
            headers: {},
            isBase64Encoded: false,
            log,
        });
        delegatedResolver.succeed(errorResponse);
    }
    //#endregion
    //#region Protected Methods
    /**
     * Get path from event with query strings
     *
     * @param event - The event sent by serverless
     */
    getPathFromEvent(event) {
        var _a;
        const stripBasePath = (0, core_1.getDefaultIfUndefined)((_a = this.options) === null || _a === void 0 ? void 0 : _a.stripBasePath, '');
        const replaceRegex = new RegExp(`^${stripBasePath}`);
        const path = event.path.replace(replaceRegex, '');
        const queryParams = event.queryStringParameters || {};
        return (0, core_1.getPathWithQueryStringParams)(path, queryParams);
    }
}
exports.ApiGatewayV1Adapter = ApiGatewayV1Adapter;
ApiGatewayV1Adapter.__type = [() => __ΩApiGatewayV1Options, 'options', 'constructor', 'getAdapterName', 'event', 'canHandle', () => __ΩAdapterRequest, 'getRequest', () => __ΩGetResponseAdapterProps, 'param0', 'getResponse', () => __ΩOnErrorProps, 'onErrorWhileForwarding', 'getPathFromEvent', 'Pn!2"8<9"0#P&0$P#2%!0&P"2%n\'0(P"o)"2*"0+P""o,#2*$0-P"2%&0.<5"""6$'];
//# sourceMappingURL=api-gateway-v1.adapter.js.map