"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpTriggerV4Adapter = exports.__ΩHttpTriggerV4AdapterOptions = void 0;
const { __ΩAdapterRequest } = require('../../contracts');
const { __ΩGetResponseAdapterProps } = require('../../contracts');
const { __ΩOnErrorProps } = require('../../contracts');
const { __ΩBothValueHeaders } = require('../../@types');
function __assignType(fn, args) {
    fn.__type = args;
    return fn;
}
//#region Imports
const url_1 = require("url");
const core_1 = require("../../core");
const __ΩHttpTriggerV4AdapterOptions = ['stripBasePath', 'P&4!8M'];
exports.__ΩHttpTriggerV4AdapterOptions = __ΩHttpTriggerV4AdapterOptions;
/**
 * The adapter to handle requests from Http Trigger on Azure Function V4.
 *
 * @example
 * ```typescript
 * const stripBasePath = '/any/custom/base/path'; // default ''
 * const adapter = new HttpTriggerV4Adapter({ stripBasePath });
 * ```
 *
 * @see {@link https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-node | Reference}
 *
 * @breadcrumb Adapters / Azure / HttpTriggerV4Adapter
 * @public
 */
class HttpTriggerV4Adapter {
    //#region Constructor
    /**
     * Default constructor
     *
     * @param options - The options to customize the {@link HttpTriggerV4Adapter}
     */
    constructor(options) {
        this.options = options;
    }
    //#endregion
    //#region Public Methods
    /**
     * {@inheritDoc}
     */
    getAdapterName() {
        return HttpTriggerV4Adapter.name;
    }
    /**
     * {@inheritDoc}
     */
    canHandle(event, context) {
        const maybeEvent = event;
        const maybeContext = context;
        return !!(maybeEvent &&
            maybeEvent.method &&
            maybeEvent.headers &&
            maybeEvent.url &&
            maybeEvent.query &&
            maybeContext &&
            maybeContext.traceContext &&
            maybeContext.bindingDefinitions &&
            maybeContext.log &&
            !!maybeContext.log.info &&
            maybeContext.bindingData);
    }
    /**
     * {@inheritDoc}
     */
    getRequest(event) {
        const path = this.getPathFromEvent(event);
        const method = event.method;
        const headers = (0, core_1.getFlattenedHeadersMap)(event.headers, ',', true);
        let body;
        if (event.body) {
            const [bufferBody, contentLength] = (0, core_1.getEventBodyAsBuffer)(event.rawBody, false);
            body = bufferBody;
            headers['content-length'] = String(contentLength);
        }
        const remoteAddress = headers['x-forwarded-for'];
        return {
            method: method,
            path,
            headers,
            remoteAddress,
            body,
        };
    }
    /**
     * {@inheritDoc}
     */
    getResponse({ body, isBase64Encoded, statusCode, headers: originalHeaders, }) {
        const headers = (0, core_1.getFlattenedHeadersMap)(originalHeaders, ',', true);
        const cookies = this.getAzureCookiesFromHeaders(originalHeaders);
        if (headers['set-cookie'])
            delete headers['set-cookie'];
        return {
            body,
            statusCode,
            headers,
            // I tried to understand this property with
            // https://docs.microsoft.com/en-us/aspnet/web-api/overview/formats-and-model-binding/content-negotiation
            // but I don't know if it's worth implementing this guy as an option
            // I found out when this guy is set to true and the framework sets content-type, azure returns 500
            // So I'll leave it as is and hope no one has any problems.
            enableContentNegotiation: false,
            cookies,
        };
    }
    /**
     * {@inheritDoc}
     */
    onErrorWhileForwarding({ error, respondWithErrors, event, delegatedResolver, log, }) {
        const body = respondWithErrors ? error.stack : '';
        const errorResponse = this.getResponse({
            event,
            statusCode: 500,
            body: body || '',
            headers: {},
            isBase64Encoded: false,
            log,
        });
        delegatedResolver.succeed(errorResponse);
    }
    //#endregion
    //#region Protected Methods
    /**
     * Get path from event with query strings
     *
     * @param event - The event sent by serverless
     */
    getPathFromEvent(event) {
        var _a;
        const stripBasePath = (0, core_1.getDefaultIfUndefined)((_a = this.options) === null || _a === void 0 ? void 0 : _a.stripBasePath, '');
        const url = new url_1.URL(event.url);
        const originalPath = url.pathname;
        const replaceRegex = new RegExp(`^${stripBasePath}`);
        const path = originalPath.replace(replaceRegex, '');
        const queryParams = event.query;
        return (0, core_1.getPathWithQueryStringParams)(path, queryParams);
    }
    /**
     * Get the Azure Cookie list parsed from set-cookie header.
     *
     * @param headers - The headers object
     */
    getAzureCookiesFromHeaders(headers) {
        const setCookie = headers['set-cookie'];
        const headerCookies = Array.isArray(setCookie)
            ? setCookie
            : setCookie
                ? [setCookie]
                : [];
        return headerCookies.map(__assignType(cookie => this.parseCookie(cookie), ['cookie', '', 'P"2!"/"']));
    }
    /**
     * Parse the string cookie to the Azure Cookie Object.
     * This code was written by {@link https://github.com/zachabney | @zachabney}
     * on {@link https://github.com/zachabney/azure-aws-serverless-express/blob/241d2d5c4d5906e4817662cad6426ec2cbbf9ca7/src/index.js#L4-L49 | this library}.
     *
     * @param cookie - The cookie
     */
    parseCookie(cookie) {
        return cookie.split(';').reduce(__assignType((azureCookieObject, cookieProperty, index) => {
            const [key, value] = cookieProperty.split('=');
            const sanitizedKey = key.toLowerCase().trim();
            const sanitizedValue = value && value.trim();
            if (index === 0) {
                azureCookieObject.name = key;
                azureCookieObject.value = sanitizedValue;
                return azureCookieObject;
            }
            switch (sanitizedKey) {
                case 'domain':
                    azureCookieObject.domain = sanitizedValue;
                    break;
                case 'path':
                    azureCookieObject.path = sanitizedValue;
                    break;
                case 'expires':
                    azureCookieObject.expires = new Date(sanitizedValue);
                    break;
                case 'secure':
                    azureCookieObject.secure = true;
                    break;
                case 'httponly':
                    azureCookieObject.httpOnly = true;
                    break;
                case 'samesite':
                    azureCookieObject.sameSite = sanitizedValue;
                    break;
                case 'max-age':
                    azureCookieObject.maxAge = Number(sanitizedValue);
                    break;
            }
            return azureCookieObject;
        }, ['azureCookieObject', 'cookieProperty', 'index', '', 'P"2!"2""2#"/$']), { name: '', value: '' });
    }
}
exports.HttpTriggerV4Adapter = HttpTriggerV4Adapter;
HttpTriggerV4Adapter.__type = [() => __ΩHttpTriggerV4AdapterOptions, 'options', 'constructor', 'getAdapterName', 'event', 'context', 'canHandle', () => __ΩAdapterRequest, 'getRequest', () => __ΩGetResponseAdapterProps, 'param0', 'getResponse', () => __ΩOnErrorProps, 'onErrorWhileForwarding', 'getPathFromEvent', () => __ΩBothValueHeaders, 'headers', 'getAzureCookiesFromHeaders', 'cookie', 'parseCookie', 'Pn!2"8<9"0#P&0$P#2%#2&)0\'P!2%n(0)P!o*"2+!0,P!!o-#2+$0.P!2%&0/<Pn021!F02<P&23!04<5!!!6$'];
//# sourceMappingURL=http-trigger-v4.adapter.js.map