"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerlessAdapter = void 0;
const { __ΩBinarySettings } = require('./@types');
const { __ΩILogger } = require('./core');
const { __ΩAdapterContract } = require('./contracts');
const { __ΩFrameworkContract } = require('./contracts');
const { __ΩResolverContract } = require('./contracts');
const { __ΩHandlerContract } = require('./contracts');
const { __ΩServerlessHandler } = require('./contracts');
const __ΩExclude = ['T', 'U', 'l6!Re$!RPe#!e$"qk#%QRb!b"Pde"!p)'];
const __ΩOmit = ['T', 'K', () => __ΩPick, () => __ΩExclude, 'b!b"e!!e!!ge!"o$#o##'];
const __ΩPick = ['T', 'K', 'l+e#!e"!fRb!b"Pde""N#!'];
const core_1 = require("./core");
//#endregion
/**
 * The class used to build the serverless handler.
 *
 * @example
 * ```typescript
 * const app = express();
 * export const handler = ServerlessAdapter.new(app)
 *   .setFramework(new ExpressFramework())
 *   .setHandler(new DefaultHandler())
 *   .setResolver(new PromiseResolver())
 *   .setRespondWithErrors(true)
 *   .addAdapter(new AlbAdapter())
 *   .addAdapter(new SQSAdapter())
 *   .addAdapter(new SNSAdapter())
 *   .build();
 * ```
 *
 * @breadcrumb ServerlessAdapter
 * @public
 */
class ServerlessAdapter {
    //#region Constructor
    /**
     * Default constructor
     */
    constructor(app) {
        //#endregion
        //#region Protected Properties
        /**
         * Settings for whether the response should be treated as binary or not
         *
         * @defaultValue `contentEncodings` and `contentTypes` are set with {@link DEFAULT_BINARY_ENCODINGS} and {@link DEFAULT_BINARY_CONTENT_TYPES}, respectively.
         */
        this.binarySettings = {
            contentEncodings: core_1.DEFAULT_BINARY_ENCODINGS,
            contentTypes: core_1.DEFAULT_BINARY_CONTENT_TYPES,
        };
        /**
         * Indicates whether the error stack should be included in the response or not
         *
         * @remarks These errors will only be included when an error occurs while forwarding the event to the framework
         * @defaultValue True when NODE_ENV is equal to `development`
         */
        this.respondWithErrors = process.env.NODE_ENV === 'development';
        /**
         * The instance of the logger service
         */
        this.log = (0, core_1.createDefaultLogger)();
        /**
         * The list of adapters used to handle an event's request and response
         */
        this.adapters = [];
        this.app = app;
    }
    //#endregion
    //#region Static Methods
    /**
     * Creates a new instance of the builder with app (express, hapi, koa, etc...)
     *
     * @param app - The instance of the app
     */
    static new(app) {
        return new ServerlessAdapter(app);
    }
    //#endregion
    //#region Builder Methods
    /**
     * Defines the handler that will get the event, context and callback and pass it to the adapter and framework
     *
     * @param handler - The implementation of the handler contract
     */
    setHandler(handler) {
        if (this.handler)
            throw new Error('SERVERLESS_ADAPTER: The handler should not set twice.');
        this.handler = handler;
        return this;
    }
    /**
     * Defines the resolver that aims to resolve the response to serverless and stop its execution when the request ends
     *
     * @param resolver - The implementation of the resolver contract
     */
    setResolver(resolver) {
        if (this.resolver)
            throw new Error('SERVERLESS_ADAPTER: The resolver should not set twice.');
        this.resolver = resolver;
        return this;
    }
    /**
     * Defines the framework that will process requests
     *
     * @param framework - The implementation of the framework contract
     */
    setFramework(framework) {
        if (this.framework) {
            throw new Error('SERVERLESS_ADAPTER: The framework should not set twice.');
        }
        this.framework = framework;
        return this;
    }
    /**
     * Defines the logger service used during the execution of the handler
     *
     * @param logger - The implementation of the logger
     */
    setLogger(logger) {
        this.log = logger;
        return this;
    }
    /**
     * Defines the binary settings for whether the response should be treated as binary or not
     *
     * @param binarySettings - The binary settings
     */
    setBinarySettings(binarySettings) {
        this.binarySettings = binarySettings;
        return this;
    }
    /**
     * Defines the responseWithErrors, a property that indicates whether the error stack should be included in the response or not
     *
     * @param respondWithErrors - Should include or not the errors in response
     */
    setRespondWithErrors(respondWithErrors) {
        this.respondWithErrors = respondWithErrors;
        return this;
    }
    /**
     * Add an adapter to the adapters list to handle the event coming from any serverless event source
     *
     * @param adapter - The implementation of the adapter contract
     */
    addAdapter(adapter) {
        this.adapters.push(adapter);
        return this;
    }
    /**
     * The builder method that returns the handler function to be exported for serverless consumption
     */
    build() {
        if (!this.resolver) {
            throw new Error('SERVERLESS_ADAPTER: Is required to set a resolver before build.');
        }
        if (!this.framework) {
            throw new Error('SERVERLESS_ADAPTER: Is required to set a framework before build.');
        }
        if (!this.handler) {
            throw new Error('SERVERLESS_ADAPTER: Is required to set a handler before build.');
        }
        if (this.adapters.length === 0) {
            throw new Error('SERVERLESS_ADAPTER: Is required to set at least one adapter.');
        }
        return this.handler.getHandler(this.app, this.framework, this.adapters, this.resolver, this.binarySettings, this.respondWithErrors, this.log);
    }
}
exports.ServerlessAdapter = ServerlessAdapter;
ServerlessAdapter.__type = ['TApp', 'TEvent', 'TContext', 'TCallback', 'TResponse', 'TReturn', 'app', 'constructor', () => __ΩBinarySettings, 'binarySettings', function () { return {
        contentEncodings: core_1.DEFAULT_BINARY_ENCODINGS,
        contentTypes: core_1.DEFAULT_BINARY_CONTENT_TYPES,
    }; }, 'respondWithErrors', function () { return process.env.NODE_ENV === 'development'; }, () => __ΩILogger, 'log', function () { return (0, core_1.createDefaultLogger)(); }, () => __ΩAdapterContract, 'adapters', function () { return []; }, () => __ΩFrameworkContract, 'framework', () => __ΩResolverContract, 'resolver', () => __ΩHandlerContract, 'handler', () => ServerlessAdapter, 'new', () => __ΩHandlerContract, () => __ΩOmit, "setHandler", 'setHandler', () => __ΩResolverContract, () => __ΩOmit, "setResolver", 'setResolver', () => __ΩFrameworkContract, () => __ΩOmit, "setFramework", 'setFramework', () => __ΩILogger, 'logger', () => __ΩOmit, "setLogger", 'setLogger', () => __ΩBinarySettings, () => __ΩOmit, "setBinarySettings", 'setBinarySettings', () => __ΩOmit, "setRespondWithErrors", 'setRespondWithErrors', () => __ΩAdapterContract, 'adapter', () => __ΩPick, "addAdapter", "build", 'addAdapter', () => __ΩServerlessHandler, 'build', 'b!b"b#b$b%b&Pe"!2\'"0(e!!3\'<n)3*<>+)3,<>-n.3/<>0e!"e!#e!%o1$F32<>3e!!o4"358<e!"e!#e!$e!%e!&o6&378<e!!e!"e!#e!$e!%e!&o8\'398<Pe"!2\'Pe#!e#"e##e#$e#%e#&7:0;sPe"!e""e"#e"$e"%e"&o<\'29!.>o=#0?Pe""e"#e"$e"%e"&o@&27!.BoA#0CPe"!oD"25!.FoE#0GPnH2I!.KoJ#0LPnM2*!.OoN#0PP)2,!.RoQ#0SPe""e"#e"%oT$2U!P.W.XJoV#0YPe"&oZ"0[5'];
//# sourceMappingURL=serverless-adapter.js.map