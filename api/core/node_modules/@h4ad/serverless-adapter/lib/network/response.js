"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerlessResponse = exports.__ΩServerlessResponseProps = void 0;
function __assignType(fn, args) {
    fn.__type = args;
    return fn;
}
const __ΩRecord = ['K', 'T', 'l\'e#"Rb!b"Pde"!N#!'];
// ATTRIBUTION: https://github.com/dougmoscrop/serverless-http
const http_1 = require("http");
const core_1 = require("../core");
const headerEnd = '\r\n\r\n';
const BODY = Symbol('Response body');
const HEADERS = Symbol('Response headers');
function getString(data) {
    if (Buffer.isBuffer(data))
        return data.toString('utf8');
    else if (typeof data === 'string')
        return data;
    else if (data instanceof Uint8Array)
        return new TextDecoder().decode(data);
    else
        throw new Error(`response.write() of unexpected type: ${typeof data}`);
}
getString.__type = ['data', 'getString', 'PP!&#J2!"/"'];
function addData(stream, data) {
    if (Buffer.isBuffer(data) ||
        typeof data === 'string' ||
        data instanceof Uint8Array)
        stream[BODY].push(Buffer.from(data));
    else
        throw new Error(`response.write() of unexpected type: ${typeof data}`);
}
addData.__type = [() => ServerlessResponse, 'stream', 'data', 'addData', 'PP7!2"PW&J2#"/$'];
const __ΩServerlessResponseProps = ['method', 'P&4!8M'];
exports.__ΩServerlessResponseProps = __ΩServerlessResponseProps;
/**
 * The class that represents a response instance used to send to the framework and wait until the framework finishes processing the request.
 * Once it's happens, we use the properties from this response to built the response to the cloud.
 *
 * @breadcrumb Network / ServerlessResponse
 * @public
 */
class ServerlessResponse extends http_1.ServerResponse {
    constructor({ method }) {
        super({ method });
        this[BODY] = [];
        this[HEADERS] = {};
        this.useChunkedEncodingByDefault = false;
        this.chunkedEncoding = false;
        this._header = '';
        const socket = {
            _writableState: {},
            writable: true,
            on: core_1.NO_OP,
            removeListener: core_1.NO_OP,
            destroy: core_1.NO_OP,
            cork: core_1.NO_OP,
            uncork: core_1.NO_OP,
            write: __assignType((data, encoding, cb) => {
                if (typeof encoding === 'function') {
                    cb = encoding;
                    encoding = null;
                }
                if (this._header === '' || this._wroteHeader)
                    addData(this, data);
                else {
                    const string = getString(data);
                    const index = string.indexOf(headerEnd);
                    if (index !== -1) {
                        const remainder = string.slice(index + headerEnd.length);
                        if (remainder)
                            addData(this, remainder);
                        this._wroteHeader = true;
                    }
                }
                if (typeof cb === 'function')
                    cb();
            }, ['data', '', 'encoding', 'cb', 'PPW&J2!P&,P$/"J2#8P$/"2$8"/"']),
        };
        this.assignSocket(socket);
    }
    get headers() {
        return this[HEADERS];
    }
    static from(res) {
        const response = new ServerlessResponse({ method: res.method });
        response.statusCode = res.statusCode || 0;
        response[HEADERS] = res.headers;
        response[BODY] = res.body ? [Buffer.from(res.body)] : [];
        response.end();
        return response;
    }
    static body(res) {
        return Buffer.concat(res[BODY]);
    }
    static headers(res) {
        const headers = res.getHeaders();
        return Object.assign(headers, res[HEADERS]);
    }
    setHeader(key, value) {
        if (this._wroteHeader)
            this[HEADERS][key] = value;
        else
            super.setHeader(key, value);
    }
    writeHead(statusCode, statusMessage, obj) {
        const headersObjOrArray = typeof statusMessage === 'string' ? obj : statusMessage;
        const arrayHeaders = Array.isArray(headersObjOrArray)
            ? headersObjOrArray
            : [headersObjOrArray || {}];
        for (const headers of arrayHeaders) {
            for (const name in headers) {
                this.setHeader(name, headers[name]);
                if (!this._wroteHeader) {
                    // we only need to initiate super.headers once
                    // writeHead will add the other headers itself
                    break;
                }
            }
        }
        return this.callNativeWriteHead(statusCode, statusMessage, obj);
    }
    /**
     * I use ignore here because in nodejs 12.x, statusMessage can be string | OutgoingHttpHeaders
     * But in nodejs \>=14.x, statusMessage can also be OutgoingHttpHeaders[]
     * I take care of these cases above, but here I can't handle it well, so I give up
     * nodejs 12.x ref: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v12/http.d.ts#L229
     * nodejs 14.x ref: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/v14/http.d.ts#L263
     */
    callNativeWriteHead(statusCode, statusMessage, obj) {
        return super.writeHead(statusCode, statusMessage, obj);
    }
}
exports.ServerlessResponse = ServerlessResponse;
ServerlessResponse.__type = [() => http_1.ServerResponse, () => __ΩServerlessResponseProps, 'param0', 'constructor', '_header', () => __ΩRecord, '_headers', '_wroteHeader', () => BODY, () => __ΩRecord, () => HEADERS, 'res', 'from', () => ServerlessResponse, 'body', 'key', 'value', 'setHeader', 'statusCode', 'statusMessage', 'obj', 'writeHead', 'callNativeWriteHead', 'P7!Pn"2#"0$&3%""o&#3\'8)3(8"F3)""o*#3+!P!2,"0-sPP7.2,!0/sP&20P\'&&F9J21"02P\'23P&""FJ248P""FJ258"06P\'23P&""FJ248P""FJ258!07<5'];
//# sourceMappingURL=response.js.map