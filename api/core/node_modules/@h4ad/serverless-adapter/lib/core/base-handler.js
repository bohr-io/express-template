"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseHandler = void 0;
const { __ΩFrameworkContract } = require('../contracts');
const { __ΩAdapterContract } = require('../contracts');
const { __ΩResolverContract } = require('../contracts');
const { __ΩBinarySettings } = require('../@types');
const { __ΩILogger } = require('./index');
const { __ΩServerlessHandler } = require('../contracts');
const { __ΩAdapterRequest } = require('../contracts');
function __assignType(fn, args) {
    fn.__type = args;
    return fn;
}
const network_1 = require("../network");
//#endregion
/**
 * The abstract class that represents the base class for a handler
 *
 * @breadcrumb Core
 * @public
 */
class BaseHandler {
    //#endregion
    //#region Protected Methods
    /**
     * Get the adapter to handle a specific event and context
     *
     * @param event - The event sent by serverless
     * @param context - The context sent by serverless
     * @param adapters - The list of adapters
     * @param log - The instance of logger
     */
    getAdapterByEventAndContext(event, context, adapters, log) {
        const resolvedAdapters = adapters.filter(__assignType(adapter => adapter.canHandle(event, context, log), ['adapter', '', 'P"2!"/"']));
        if (resolvedAdapters.length === 0) {
            throw new Error("SERVERLESS_ADAPTER: Couldn't find adapter to handle this event.");
        }
        if (resolvedAdapters.length > 1) {
            throw new Error(`SERVERLESS_ADAPTER: Two or more adapters was resolved by the event, the adapters are: ${adapters
                .map(__assignType(adapter => adapter.getAdapterName(), ['adapter', '', 'P"2!"/"']))
                .join(', ')}.`);
        }
        return resolvedAdapters[0];
    }
    /**
     * Get serverless request and response frmo the adapter request
     *
     * @param requestValues - The request values from adapter
     */
    getServerlessRequestResponseFromAdapterRequest(requestValues) {
        const request = new network_1.ServerlessRequest({
            method: requestValues.method,
            headers: requestValues.headers,
            body: requestValues.body,
            remoteAddress: requestValues.remoteAddress,
            url: requestValues.path,
        });
        const response = new network_1.ServerlessResponse({
            method: requestValues.method,
        });
        return [request, response];
    }
}
exports.BaseHandler = BaseHandler;
BaseHandler.__type = ['TApp', 'TEvent', 'TContext', 'TCallback', 'TResponse', 'TReturn', 'app', () => __ΩFrameworkContract, 'framework', () => __ΩAdapterContract, 'adapters', () => __ΩResolverContract, 'resolverFactory', () => __ΩBinarySettings, 'binarySettings', 'respondWithErrors', () => __ΩILogger, 'log', () => __ΩServerlessHandler, 'getHandler', 'event', 'context', () => __ΩAdapterContract, () => __ΩILogger, () => __ΩAdapterContract, 'getAdapterByEventAndContext', () => __ΩAdapterRequest, 'requestValues', () => network_1.ServerlessRequest, 'request', () => network_1.ServerlessResponse, 'response', 'getServerlessRequestResponseFromAdapterRequest', 'b!b"b#b$b%b&Pe"!2\'e"!o("2)e""e"#e"%o*$F2+e""e"#e"$e"%e"&o,&2-n.2/)20n122e"&o3"04=Pe""25e"#26e""e"#e"%o7$F2+n822e""e"#e"%o9$0:<Pn;2<PP7=I>P7?I@G0A<5e!!e!"e!#e!$e!%e!&6\''];
//# sourceMappingURL=base-handler.js.map